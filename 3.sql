DROP TABLE tabla_jscg;

DROP TABLE tabla_jscg RESTRICT;

DROP TABLE tabla_jscg CASCADE;

-- Eliminar tabla temporal

DROP TABLE CALCULOS_TEMPORALES_JSCG;

-- Con seguridad adicional

DROP TABLE IF EXISTS CALCULOS_TEMPORALES_JSCG;

SELECT * FROM CLIENTES_JSCG;

SELECT NOMBRE, EMAIL

FROM CLIENTES_JSCG;

SELECT NOMBRE, APELLIDO

FROM CLIENTES_JSCG

ORDER BY APELLIDO ASC;

SELECT NOMBRE, TOTAL

FROM PEDIDOS_JSCG

ORDER BY TOTAL DESC;

SELECT COUNT(*)

FROM CLIENTES_JSCG;

SELECT COUNT(*)

FROM CLIENTES_JSCG

WHERE ACTIVO = TRUE;

SELECT COUNT(TELEFONO)

FROM CLIENTES_JSCG;

SELECT SUM(TOTAL)

FROM PEDIDOS_JSCG;

SELECT SUM(TOTAL)

FROM PEDIDOS_JSCG

WHERE ID_CLIENTE = 101;

SELECT AVG(PRECIO_UNITARIO)

FROM PRODUCTOS_JSCG;

SELECT ID_CLIENTE,

SUM(TOTAL) as VENTAS_TOTALES

FROM PEDIDOS_JSCG

GROUP BY ID_CLIENTE;

SELECT ID_CLIENTE,

ESTADO,

COUNT(*) as NUM_PEDIDOS,

SUM(TOTAL) as TOTAL_VENTAS

FROM PEDIDOS_JSCG

GROUP BY ID_CLIENTE, ESTADO;

SELECT NOMBRE, EMAIL

FROM CLIENTES_JSCG

WHERE CIUDAD = 'Bogotá';

SELECT NOMBRE, EMAIL

FROM CLIENTES_JSCG

WHERE CIUDAD = 'Bogotá'

AND ACTIVO = TRUE;

SELECT NOMBRE_PRODUCTO, PRECIO_UNITARIO

FROM PRODUCTOS_JSCG

WHERE PRECIO_UNITARIO BETWEEN 50000 AND 200000;

SELECT NOMBRE, CIUDAD

FROM CLIENTES_JSCG

WHERE CIUDAD IN ('Bogotá', 'Medellín', 'Cali');

SELECT NOMBRE, APELLIDO

FROM CLIENTES_JSCG

WHERE NOMBRE LIKE 'J%';

SELECT NOMBRE, EMAIL

FROM CLIENTES_JSCG

WHERE TELEFONO IS NULL;

SELECT NOMBRE_PRODUCTO, PRECIO_UNITARIO

FROM PRODUCTOS_JSCG

WHERE PRECIO_UNITARIO BETWEEN 50000 AND 200000;

WHERE NOMBRE LIKE 'Mar%';

WHERE APELLIDO LIKE '%ez';

WHERE NOMBRE LIKE '%ana%';

WHERE CODIGO LIKE 'P____';

WHERE TELEFONO LIKE '3__-____';

SELECT NOMBRE, EMAIL FROM

CLIENTES_JSCG;

SELECT TOP 100 NOMBRE

FROM CLIENTES_JSCG

ORDER BY FECHA_REGISTRO DESC;

EXPLAIN SELECT * FROM PEDIDOS_JSCG

WHERE FECHA_PEDIDO >= '2024-01-01';

SELECT CURRENT_DATE;

SELECT CURRENT_TIME;

SELECT CURRENT_TIMESTAMP;

CREATE TABLE ESTUDIANTES_JSCG (

ID_ESTUDIANTE INT,

NOMBRE VARCHAR(100),

APELLIDO VARCHAR(100),

FECHA_NACIMIENTO DATE,

PROMEDIO DECIMAL(4,2),

EMAIL VARCHAR(150),

ACTIVO BOOLEAN,

FECHA_INSCRIPCION TIMESTAMP

);

CREATE TABLE CLIENTES_JSCG (

ID_CLIENTE INT,

NOMBRE VARCHAR(50)

);

CREATE TABLE EMPLEADOS_JSCG (

ID_EMPLEADO INT PRIMARY KEY,

NOMBRE VARCHAR(100),

CARGO VARCHAR(50)

);

CREATE TABLE INSCRIPCIONES_JSCG (

ID_ESTUDIANTE INT,

ID_CURSO INT,

FECHA_INSCRIPCION DATE,

PRIMARY KEY (ID_ESTUDIANTE, ID_CURSO)

);

CREATE TABLE CLIENTES_JSCG (

ID_CLIENTE INT PRIMARY KEY,

NOMBRE VARCHAR(100) NOT NULL,

EMAIL VARCHAR(100) UNIQUE

);

CREATE TABLE PEDIDOS_JSCG (

ID_PEDIDO INT PRIMARY KEY,

ID_CLIENTE INT NOT NULL,

FECHA_PEDIDO DATE NOT NULL,

TOTAL DECIMAL(10,2),

-- Esta es la clave foránea

FOREIGN KEY (ID_CLIENTE)

REFERENCES CLIENTES_JSCG(ID_CLIENTE)

);

CREATE TABLE PRODUCTOS_JSCG (

ID_PRODUCTO INT PRIMARY KEY,

NOMBRE VARCHAR(100),

PRECIO DECIMAL(10,2),

DESCUENTO INT,

CHECK (PRECIO > 0),

CHECK (DESCUENTO >= 0 AND DESCUENTO <=

100)

);

CREATE TABLE EMPLEADOS_JSCG (

ID_EMPLEADO INT PRIMARY KEY,

NOMBRE VARCHAR(100),

FECHA_NACIMIENTO DATE,

FECHA_CONTRATACION DATE,

CHECK (FECHA_CONTRATACION >

FECHA_NACIMIENTO)

);

CREATE TABLE ESTUDIANTES_JSCG (

ID_ESTUDIANTE INT PRIMARY KEY,

NOMBRE VARCHAR(100),

GENERO CHAR(1),

ESTADO_CIVIL VARCHAR(20),

CHECK (GENERO IN ('M', 'F', 'O')),

CHECK (ESTADO_CIVIL IN ('Soltero', 'Casado', 'Divorciado', 'Viudo'))

);

CREATE TABLE PRODUCTOS_JSCG (

ID_PRODUCTO INT

PRIMARY KEY,

NOMBRE VARCHAR(100),

STOCK INT DEFAULT 0,

ACTIVO BOOLEAN DEFAULT

TRUE,

DESCUENTO DECIMAL(5,2)

DEFAULT 0.00

);

CREATE TABLE REGISTROS_JSCG (

ID_REGISTRO INT PRIMARY

KEY,

DESCRIPTION TEXT,

FECHA_CREACION DATE

DEFAULT CURRENT_DATE,

FECHA_ACTUALIZACION

TIMESTAMP DEFAULT

CURRENT_TIMESTAMP

);

CREATE TABLE LIBROS_JSCG (

-- Identificador único del libro

ID_LIBRO INT PRIMARY KEY,

-- Información obligatoria del libro

TITULO VARCHAR(200) NOT NULL,

AUTOR VARCHAR(150) NOT NULL,

ISBN VARCHAR(13) UNIQUE NOT NULL,

-- Detalles del libro con validaciones

ANIO_PUBLICACION INT,

NUMERO_PAGINAS INT,

EDITORIAL VARCHAR(100),

-- Control de disponibilidad

DISPONIBLE BOOLEAN DEFAULT TRUE,

CANTIDAD_COPIAS INT DEFAULT 1,

-- Registro automático de fecha

FECHA_REGISTRO DATE DEFAULT CURRENT_DATE,

-- Validaciones con CHECK

CHECK (ANIO_PUBLICACION > 1000 AND ANIO_PUBLICACION <= EXTRACT(YEAR FROM CURRENT_DATE)),

CHECK (NUMERO_PAGINAS > 0),

CHECK (CANTIDAD_COPIAS >= 0)

);

ALTER TABLE LIBROS_JSCG

ADD COLUMN CATEGORIA

VARCHAR(50);

ALTER TABLE LIBROS_JSCG

ALTER COLUMN

DISPONIBLE SET

DEFAULT FALSE;

ALTER TABLE LIBROS_JSCG

DROP COLUMN

NUMERO_PAGINAS;

-- 1. Tabla de Clientes

CREATE TABLE CLIENTES_JSCG (

ID_CLIENTE INT PRIMARY KEY,

NOMBRE VARCHAR(100) NOT NULL,

APELLIDO VARCHAR(100) NOT NULL,

EMAIL VARCHAR(100) UNIQUE NOT NULL,

TELEFONO VARCHAR(20),

DIRECCION TEXT,

CIUDAD VARCHAR(50),

FECHA_REGISTRO DATE DEFAULT CURRENT_DATE,

ACTIVO BOOLEAN DEFAULT TRUE

);

-- 2. Tabla de Categorías de Productos

CREATE TABLE CATEGORIAS_JSCG (

ID_CATEGORIA INT PRIMARY KEY,

NOMBRE_CATEGORIA VARCHAR(50) UNIQUE NOT NULL,

DESCRIPTION TEXT

);

-- 3. Tabla de Productos

CREATE TABLE PRODUCTOS_JSCG (

ID_PRODUCTO INT PRIMARY KEY,

NOMBRE_PRODUCTO VARCHAR(100) NOT NULL,

DESCRIPTION TEXT,

ID_CATEGORIA INT NOT NULL,

PRECIO_UNITARIO DECIMAL(10,2) NOT NULL,

STOCK_ACTUAL INT DEFAULT 0,

STOCK_MINIMO INT DEFAULT 10,

ACTIVO BOOLEAN DEFAULT TRUE,

FOREIGN KEY (ID_CATEGORIA) REFERENCES CATEGORIAS_JSCG(ID_CATEGORIA),

CHECK (PRECIO_UNITARIO > 0),

CHECK (STOCK_ACTUAL >= 0),

CHECK (STOCK_MINIMO >= 0)

);

-- 4. Tabla de Pedidos (Cabecera)

CREATE TABLE PEDIDOS_JSCG (

ID_PEDIDO INT PRIMARY KEY,

ID_CLIENTE INT NOT NULL,

FECHA_PEDIDO TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

ESTADO VARCHAR(20) DEFAULT 'Pendiente',

SUBTOTAL DECIMAL(10,2) DEFAULT 0,

IMPUESTO DECIMAL(10,2) DEFAULT 0,

TOTAL DECIMAL(10,2) DEFAULT 0,

OBSERVACIONES TEXT,

FOREIGN KEY (ID_CLIENTE) REFERENCES CLIENTES_JSCG(ID_CLIENTE),

CHECK (ESTADO IN ('Pendiente', 'Procesando', 'Enviado', 'Entregado', 'Cancelado')),

CHECK (SUBTOTAL >= 0),

CHECK (IMPUESTO >= 0),

CHECK (TOTAL >= 0)

);

-- 5. Tabla de Detalle de Pedidos (Líneas de pedido)

CREATE TABLE DETALLE_PEDIDOS_JSCG (

ID_DETALLE INT PRIMARY KEY,

ID_PEDIDO INT NOT NULL,

ID_PRODUCTO INT NOT NULL,

CANTIDAD INT NOT NULL,

PRECIO_UNITARIO DECIMAL(10,2) NOT NULL,

DESCUENTO DECIMAL(5,2) DEFAULT 0,

SUBTOTAL DECIMAL(10,2) NOT NULL,

FOREIGN KEY (ID_PEDIDO) REFERENCES PEDIDOS_JSCG(ID_PEDIDO) ON DELETE CASCADE,

FOREIGN KEY (ID_PRODUCTO) REFERENCES PRODUCTOS_JSCG(ID_PRODUCTO),

CHECK (CANTIDAD > 0),

CHECK (PRECIO_UNITARIO > 0),

CHECK (DESCUENTO >= 0 AND DESCUENTO <= 100),

CHECK (SUBTOTAL >= 0)

);

-- 6. Tabla de Métodos de Pago

CREATE TABLE PAGOS_JSCG (

ID_PAGO INT PRIMARY KEY,

ID_PEDIDO INT NOT NULL,

FECHA_PAGO TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

MONTO DECIMAL(10,2) NOT NULL,

METODO_PAGO VARCHAR(30) NOT NULL,

NUMERO_REFERENCIA VARCHAR(50),

ESTADO VARCHAR(20) DEFAULT 'Completado',

FOREIGN KEY (ID_PEDIDO) REFERENCES PEDIDOS_JSCG(ID_PEDIDO),

CHECK (MONTO > 0),

CHECK (METODO_PAGO IN ('Efectivo', 'Tarjeta Crédito', 'Tarjeta Débito', 'Transferencia', 'PSE')),

CHECK (ESTADO IN ('Pendiente', 'Completado', 'Rechazado', 'Reembolsado'))

);

SELECT C.NOMBRE,

P.FECHA_PEDIDO, P.TOTAL

FROM CLIENTES_JSCG C

INNER JOIN PEDIDOS_JSCG P ON C.ID_CLIENTE =

P.ID_CLIENTE;

SELECT C.NOMBRE, P.TOTAL

FROM CLIENTES_JSCG C

LEFT JOIN PEDIDOS_JSCG P

ON C.ID_CLIENTE =

P.ID_CLIENTE;

SELECT C.NOMBRE, P.TOTAL

FROM CLIENTES_JSCG C

RIGHT JOIN PEDIDOS_JSCG P

ON C.ID_CLIENTE =

P.ID_CLIENTE;

SELECT C.NOMBRE, P.TOTAL

FROM CLIENTES_JSCG C

FULL OUTER JOIN PEDIDOS_JSCG P

ON C.ID_CLIENTE =

P.ID_CLIENTE;

SELECT

C.ID_CLIENTE,

C.NOMBRE,

C.APELLIDO,

COUNT(P.ID_PEDIDO) as TOTAL_PEDIDOS,

SUM(P.TOTAL) as VENTAS_TOTALES

FROM CLIENTES_JSCG C

JOIN PEDIDOS_JSCG P ON C.ID_CLIENTE = P.ID_CLIENTE

WHERE P.ESTADO = 'Entregado'

GROUP BY C.ID_CLIENTE, C.NOMBRE, C.APELLIDO

ORDER BY VENTAS_TOTALES DESC

LIMIT 10;

SELECT

CAT.NOMBRE_CATEGORIA,

P.NOMBRE_PRODUCTO,

SUM(DP.CANTIDAD) as UNIDADES_VENDIDAS,

SUM(DP.SUBTOTAL) as INGRESOS_TOTALES

FROM CATEGORIAS_JSCG CAT

JOIN PRODUCTOS_JSCG P ON CAT.ID_CATEGORIA =

P.ID_CATEGORIA

JOIN DETALLE_PEDIDOS_JSCG DP ON P.ID_PRODUCTO =

DP.ID_PRODUCTO

JOIN PEDIDOS_JSCG PED ON DP.ID_PEDIDO =

PED.ID_PEDIDO

WHERE PED.ESTADO = 'Entregado'

GROUP BY CAT.NOMBRE_CATEGORIA,

P.NOMBRE_PRODUCTO

ORDER BY CAT.NOMBRE_CATEGORIA,

UNIDADES_VENDIDAS DESC;

SELECT

P.ID_PRODUCTO,

P.NOMBRE_PRODUCTO,

C.NOMBRE_CATEGORIA,

P.STOCK_ACTUAL,

P.STOCK_MINIMO,

(P.STOCK_MINIMO - P.STOCK_ACTUAL) as

DEFICIT

FROM PRODUCTOS_JSCG P

JOIN CATEGORIAS_JSCG C ON P.ID_CATEGORIA =

C.ID_CATEGORIA

WHERE P.STOCK_ACTUAL < P.STOCK_MINIMO

AND P.ACTIVO = TRUE

ORDER BY DEFICIT DESC;

INSERT INTO CLIENTES_JSCG

(ID_CLIENTE, NOMBRE, APELLIDO, EMAIL)

VALUES

(1, 'Johan', 'Castro', 'johan@email.com');

INSERT INTO CLIENTES_JSCG

VALUES

(2, 'Sebastian', 'Gonzalez',

'sebastian@email.com', '3001234567',

'Calle 123', 'Bogotá',

CURRENT_DATE, TRUE);

INSERT INTO CATEGORIAS_JSCG

(ID_CATEGORIA, NOMBRE_CATEGORIA)

VALUES

(1, 'Electrónica'),

(2, 'Ropa'),

(3, 'Alimentos'),

(4, 'Libros'),

(5, 'Deportes');

UPDATE CLIENTES_JSCG

SET EMAIL = 'nuevo@email.com'

WHERE ID_CLIENTE = 1;

UPDATE PRODUCTOS_JSCG

SET PRECIO_UNITARIO = 150000,

STOCK_ACTUAL = 50

WHERE ID_PRODUCTO = 101;

UPDATE PRODUCTOS_JSCG

SET PRECIO_UNITARIO = PRECIO_UNITARIO * 1.10

WHERE ID_CATEGORIA = 1;

UPDATE CLIENTES_JSCG

SET ACTIVO = FALSE

WHERE ID_CLIENTE NOT IN (

SELECT DISTINCT ID_CLIENTE

FROM PEDIDOS_JSCG

WHERE FECHA_PEDIDO >= CURRENT_DATE - INTERVAL '6 months'

);

UPDATE PRODUCTOS_JSCG

SET STOCK_ACTUAL = STOCK_ACTUAL - 5

WHERE ID_PRODUCTO = 201

AND STOCK_ACTUAL >= 5;

DELETE FROM CLIENTES_JSCG

WHERE ID_CLIENTE = 999;

DELETE FROM PRODUCTOS_JSCG

WHERE ACTIVO = FALSE

AND STOCK_ACTUAL = 0;

DELETE FROM PEDIDOS_JSCG

WHERE ESTADO =

'Cancelado'

AND FECHA_PEDIDO <

CURRENT_DATE - INTERVAL

'1 year';

DELETE FROM

DETALLE_PEDIDOS_JSCG

WHERE ID_PEDIDO IN (

SELECT ID_PEDIDO

FROM PEDIDOS_JSCG

WHERE ESTADO =

'Cancelado'

);

DELETE FROM

TABLA_TEMPORAL_JSCG;

TRUNCATE TABLE

TABLA_TEMPORAL_JSCG;

-- Iniciar transacción

BEGIN TRANSACTION;

-- Reducir stock en bodega origen

UPDATE PRODUCTOS_JSCG

SET STOCK_ACTUAL = STOCK_ACTUAL - 10

WHERE ID_PRODUCTO = 101 AND STOCK_ACTUAL >= 10;

-- Aumentar stock en bodega destino

UPDATE PRODUCTOS_JSCG

SET STOCK_ACTUAL = STOCK_ACTUAL + 10

WHERE ID_PRODUCTO = 101;

-- Registrar el movimiento

INSERT INTO MOVIMIENTOS_INVENTARIO_JSCG

(ID_PRODUCTO, TIPO_MOVIMIENTO, CANTIDAD, FECHA)

VALUES

(101, 'Transferencia', 10, CURRENT_TIMESTAMP);

-- Si todo salió bien, confirmar cambios

COMMIT;

-- Si algo salió mal, deshacer todo

-- ROLLBACK;

CREATE VIEW VISTA_CLIENTES_RESUMEN_JSCG AS

SELECT

C.ID_CLIENTE,

C.NOMBRE,

C.APELLIDO,

C.EMAIL,

COUNT(P.ID_PEDIDO) as TOTAL_PEDIDOS,

COALESCE(SUM(P.TOTAL), 0) as TOTAL_GASTADO,

MAX(P.FECHA_PEDIDO) as ULTIMA_COMPRA

FROM CLIENTES_JSCG C

LEFT JOIN PEDIDOS_JSCG P ON C.ID_CLIENTE = P.ID_CLIENTE

GROUP BY C.ID_CLIENTE, C.NOMBRE, C.APELLIDO, C.EMAIL;

CREATE VIEW VISTA_PRODUCTOS_BAJO_STOCK_JSCG AS

SELECT

P.ID_PRODUCTO,

P.NOMBRE_PRODUCTO,

C.NOMBRE_CATEGORIA,

P.STOCK_ACTUAL,

P.STOCK_MINIMO,

(P.STOCK_MINIMO - P.STOCK_ACTUAL) as DEFICIT

FROM PRODUCTOS_JSCG P

JOIN CATEGORIAS_JSCG C ON P.ID_CATEGORIA = C.ID_CATEGORIA

WHERE P.STOCK_ACTUAL < P.STOCK_MINIMO

AND P.ACTIVO = TRUE;

CREATE PROCEDURE sp_registrar_cliente_jscg

@nombre VARCHAR(100),

@apellido VARCHAR(100),

@email VARCHAR(100),

@telefono VARCHAR(20),

@ciudad VARCHAR(50)

AS

BEGIN

-- Verificar si email ya existe

IF EXISTS (SELECT 1 FROM CLIENTES_JSCG WHERE EMAIL = @email)

BEGIN

RAISERROR('El email ya está registrado', 16, 1);

RETURN;

END

-- Insertar nuevo cliente

INSERT INTO CLIENTES_JSCG

(NOMBRE, APELLIDO, EMAIL, TELEFONO, CIUDAD, FECHA_REGISTRO, ACTIVO)

VALUES

(@nombre, @apellido, @email, @telefono, @ciudad, CURRENT_DATE, TRUE);

-- Devolver ID del nuevo cliente

SELECT SCOPE_IDENTITY() as NUEVO_ID_CLIENTE;

END;

CREATE TABLE AUDITORIA_PRECIOS_JSCG (

ID_AUDITORIA INT PRIMARY KEY AUTO_INCREMENT,

ID_PRODUCTO INT NOT NULL,

PRECIO_ANTERIOR DECIMAL(10,2),

PRECIO_NUEVO DECIMAL(10,2),

FECHA_CAMBIO TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

USUARIO VARCHAR(50)

);

CREATE TRIGGER trg_auditoria_precio_producto_jscg

AFTER UPDATE ON PRODUCTOS_JSCG

FOR EACH ROW

BEGIN

IF OLD.PRECIO_UNITARIO != NEW.PRECIO_UNITARIO THEN

INSERT INTO AUDITORIA_PRECIOS_JSCG

(ID_PRODUCTO, PRECIO_ANTERIOR, PRECIO_NUEVO, USUARIO)

VALUES

(NEW.ID_PRODUCTO, OLD.PRECIO_UNITARIO,

NEW.PRECIO_UNITARIO, CURRENT_USER());

END IF;

END;

CREATE FUNCTION calcular_descuento_jscg

(@precio DECIMAL(10,2),

@porcentaje INT)

RETURNS DECIMAL(10,2)

AS

BEGIN

RETURN @precio * (1 - @porcentaje/100.0);

END;

SELECT

NOMBRE_PRODUCTO,

PRECIO_UNITARIO,

dbo.calcular_descuento_jscg(PRECIO_UNITARIO, 15)

as PRECIO_CON_DESCUENTO

FROM PRODUCTOS_JSCG;

CREATE FUNCTION obtener_pedidos_cliente_jscg

(@id_cliente INT)

RETURNS TABLE

AS

RETURN (

SELECT

ID_PEDIDO,

FECHA_PEDIDO,

TOTAL,

ESTADO

FROM PEDIDOS_JSCG

WHERE ID_CLIENTE = @id_cliente

);

SELECT * FROM obtener_pedidos_cliente_jscg(101);

WITH

-- CTE 1: Calcular total por cliente

VentasPorCliente_JSCG AS (

SELECT

ID_CLIENTE,

COUNT(*) as NUM_PEDIDOS,

SUM(TOTAL) as TOTAL_GASTADO

FROM PEDIDOS_JSCG

WHERE ESTADO = 'Entregado'

GROUP BY ID_CLIENTE

),

-- CTE 2: Categorizar clientes

CategoriasCliente_JSCG AS (

SELECT

ID_CLIENTE,

NUM_PEDIDOS,

TOTAL_GASTADO,

CASE

WHEN TOTAL_GASTADO >= 5000000 THEN 'Premium'

WHEN TOTAL_GASTADO >= 1000000 THEN 'Regular'

ELSE 'Básico'

END as CATEGORIA

FROM VentasPorCliente_JSCG

)

-- Consulta final usando ambos CTE

SELECT

C.NOMBRE,

C.APELLIDO,

CC.NUM_PEDIDOS,

CC.TOTAL_GASTADO,

CC.CATEGORIA

FROM CategoriasCliente_JSCG CC

JOIN CLIENTES_JSCG C ON CC.ID_CLIENTE = C.ID_CLIENTE

WHERE CC.CATEGORIA = 'Premium'

ORDER BY CC.TOTAL_GASTADO DESC;

SELECT

NOMBRE_PRODUCTO,

PRECIO_UNITARIO,

ROW_NUMBER() OVER (

ORDER BY PRECIO_UNITARIO DESC

) as NUMERO_FILA,

RANK() OVER (

ORDER BY PRECIO_UNITARIO DESC

) as RANKING

FROM PRODUCTOS_JSCG;

SELECT

NOMBRE_CATEGORIA,

NOMBRE_PRODUCTO,

PRECIO_UNITARIO,

RANK() OVER (

PARTITION BY ID_CATEGORIA

ORDER BY PRECIO_UNITARIO DESC

) as RANKING_EN_CATEGORIA... FROM PRODUCTOS_JSCG P

JOIN CATEGORIAS_JSCG C

ON P.ID_CATEGORIA = C.ID_CATEGORIA;

SELECT

FECHA_PEDIDO,

TOTAL,

LAG(TOTAL, 1) OVER (ORDER BY

FECHA_PEDIDO) as VENTA_ANTERIOR,

LEAD(TOTAL, 1) OVER (ORDER BY

FECHA_PEDIDO) as VENTA_SIGUIENTE,

TOTAL - LAG(TOTAL, 1) OVER (ORDER BY

FECHA_PEDIDO) as DIFERENCIA

FROM PEDIDOS_JSCG

WHERE ID_CLIENTE = 101;

SELECT

FECHA_PEDIDO,

TOTAL,

SUM(TOTAL) OVER (

ORDER BY FECHA_PEDIDO

) as TOTAL_ACUMULADO,

AVG(TOTAL) OVER (

ORDER BY FECHA_PEDIDO

ROWS BETWEEN 2 PRECEDING AND

CURRENT ROW

) as PROMEDIO_MOVIL_3_DIAS

FROM PEDIDOS_JSCG

WHERE EXTRACT(YEAR FROM FECHA_PEDIDO) =

2024;

SELECT

NOMBRE_PRODUCTO,

STOCK_ACTUAL,

CASE

WHEN STOCK_ACTUAL = 0

THEN 'Agotado'

WHEN STOCK_ACTUAL < STOCK_MINIMO

THEN 'Bajo'

WHEN STOCK_ACTUAL < STOCK_MINIMO * 2

THEN 'Medio'

ELSE 'Suficiente'

END as ESTADO_STOCK

FROM PRODUCTOS_JSCG;

SELECT

ID_CATEGORIA,

COUNT(*) as TOTAL_PRODUCTOS,

SUM(CASE

WHEN STOCK_ACTUAL = 0 THEN 1

ELSE 0

END) as PRODUCTOS_AGOTADOS,

SUM(CASE

WHEN ACTIVO = TRUE THEN 1

ELSE 0

END) as PRODUCTOS_ACTIVOS

FROM PRODUCTOS_JSCG

GROUP BY ID_CATEGORIA;

SELECT EMAIL, COUNT(*) as

CANTIDAD

FROM CLIENTES_JSCG

GROUP BY EMAIL

HAVING COUNT(*) > 1;

SELECT C.*

FROM CLIENTES_JSCG C

JOIN (

SELECT EMAIL

FROM CLIENTES_JSCG

GROUP BY EMAIL

HAVING COUNT(*) > 1

) DUPS ON C.EMAIL =

DUPS.EMAIL

ORDER BY C.EMAIL,

C.ID_CLIENTE;

ALTER TABLE CLIENTES_JSCG

ADD CONSTRAINT uk_email_jscg

UNIQUE (EMAIL);

INSERT INTO CLIENTES_JSCG (EMAIL,

NOMBRE)

SELECT 'nuevo@email.com',

'Nuevo Cliente'

WHERE NOT EXISTS (

SELECT 1 FROM CLIENTES_JSCG

WHERE EMAIL =

'nuevo@email.com'

);

WITH ClientesRankeados_JSCG AS (

SELECT *,

ROW_NUMBER() OVER (

PARTITION BY EMAIL

ORDER BY FECHA_REGISTRO

DESC

) as rn

FROM CLIENTES_JSCG

)

DELETE FROM CLIENTES_JSCG

WHERE ID_CLIENTE IN (

SELECT ID_CLIENTE

FROM ClientesRankeados_JSCG

WHERE rn > 1

);

-- MySQL

SELECT 'ID', 'Nombre', 'Email'

UNION ALL

SELECT ID_CLIENTE, NOMBRE, EMAIL

FROM CLIENTES_JSCG

INTO OUTFILE '/tmp/clientes_jscg.csv'

FIELDS TERMINATED BY ','

ENCLOSED BY '"'

LINES TERMINATED BY '\n';

-- PostgreSQL

COPY CLIENTES_JSCG TO '/tmp/clientes_jscg.csv'

CSV HEADER;

-- MySQL

LOAD DATA INFILE '/tmp/clientes_jscg.csv'

INTO TABLE CLIENTES_JSCG

FIELDS TERMINATED BY ','

ENCLOSED BY '"'

LINES TERMINATED BY '\n'

IGNORE 1 ROWS;

-- PostgreSQL

COPY CLIENTES_JSCG FROM '/tmp/clientes_jscg.csv'

CSV HEADER;

SELECT

FECHA_PEDIDO,

EXTRACT(YEAR FROM

FECHA_PEDIDO) as AÑO,

EXTRACT(MONTH FROM

FECHA_PEDIDO) as MES,

EXTRACT(DAY FROM

FECHA_PEDIDO) as DIA

FROM PEDIDOS_JSCG;

SELECT

CURRENT_DATE,

CURRENT_DATE +

INTERVAL '7 days'

as

UNA_SEMANA_DESPUES,

CURRENT_DATE -

INTERVAL '30 days'

as HACE_UN_MES;

SELECT

ID_PEDIDO,

FECHA_PEDIDO,

CURRENT_DATE -

FECHA_PEDIDO

as DIAS_DESDE_PEDIDO

FROM PEDIDOS_JSCG;

-- PostgreSQL

SELECT TO_CHAR(

FECHA_PEDIDO,

'DD/MM/YYYY HH24:MI:SS'

) FROM PEDIDOS_JSCG;

-- MySQL

SELECT DATE_FORMAT(

FECHA_PEDIDO,

'%d/%m/%Y %H:%i:%s'

) FROM PEDIDOS_JSCG;

-- SQL Server

SELECT FORMAT(

FECHA_PEDIDO,

'dd/MM/yyyy HH:mm:ss'

) FROM PEDIDOS_JSCG;

-- Ventas mensuales del último año

SELECT

EXTRACT(YEAR FROM FECHA_PEDIDO) as AÑO,

EXTRACT(MONTH FROM FECHA_PEDIDO) as MES,

COUNT(*) as NUM_PEDIDOS,

SUM(TOTAL) as VENTAS_TOTALES,

AVG(TOTAL) as TICKET_PROMEDIO

FROM PEDIDOS_JSCG

WHERE FECHA_PEDIDO >= CURRENT_DATE - INTERVAL '1 year'

AND ESTADO = 'Entregado'

GROUP BY

EXTRACT(YEAR FROM FECHA_PEDIDO),

EXTRACT(MONTH FROM FECHA_PEDIDO)

ORDER BY AÑO, MES;

WITH VentasDiarias_JSCG AS (

SELECT

DATE(FECHA_PEDIDO) as FECHA,

SUM(TOTAL) as VENTAS

FROM PEDIDOS_JSCG

WHERE ESTADO = 'Entregado'

GROUP BY DATE(FECHA_PEDIDO)

)

SELECT

FECHA,

VENTAS,

AVG(VENTAS) OVER (

ORDER BY FECHA

ROWS BETWEEN 6 PRECEDING AND CURRENT ROW

) as PROMEDIO_MOVIL_7_DIAS,

VENTAS - LAG(VENTAS, 7) OVER (ORDER BY FECHA)

as CAMBIO_SEMANAL,

(VENTAS - LAG(VENTAS, 7) OVER (ORDER BY FECHA)) /

NULLIF(LAG(VENTAS, 7) OVER (ORDER BY FECHA), 0) * 100

as CAMBIO_PORCENTUAL

FROM VentasDiarias_JSCG

ORDER BY FECHA DESC

LIMIT 30;

CREATE TABLE INSTITUCIONES_JSCG (

ID_INSTITUCION INT PRIMARY KEY AUTO_INCREMENT,

NOMBRE VARCHAR(200) NOT NULL,

TIPO_INSTITUCION ENUM('Universidad', 'Instituto', 'Colegio') NOT NULL,

CIUDAD VARCHAR(100),

DIRECCION TEXT,

TELEFONO VARCHAR(20),

EMAIL VARCHAR(100) UNIQUE,

FECHA_FUNDACION DATE,

ACTIVA BOOLEAN DEFAULT TRUE,

CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP

);

CREATE TABLE PROGRAMAS_ACADEMICOS_JSCG (

ID_PROGRAMA INT PRIMARY KEY AUTO_INCREMENT,

ID_INSTITUCION INT NOT NULL,

CODIGO_PROGRAMA VARCHAR(20) UNIQUE NOT NULL,

NOMBRE_PROGRAMA VARCHAR(200) NOT NULL,

NIVEL ENUM('Técnico', 'Tecnológico', 'Profesional', 'Especialización', 'Maestría', 'Doctorado'),

DURACION_SEMESTRES INT,

CREDITOS_TOTALES INT,

MODALIDAD ENUM('Presencial', 'Virtual', 'Semi-presencial') DEFAULT 'Presencial',

ACTIVO BOOLEAN DEFAULT TRUE,

FOREIGN KEY (ID_INSTITUCION) REFERENCES INSTITUCIONES_JSCG(ID_INSTITUCION),

CHECK (DURACION_SEMESTRES > 0),

CHECK (CREDITOS_TOTALES > 0)

);

CREATE TABLE ESTUDIANTES_JSCG (

ID_ESTUDIANTE INT PRIMARY KEY AUTO_INCREMENT,

TIPO_DOCUMENTO ENUM('CC', 'TI', 'CE', 'Pasaporte') NOT NULL,

NUMERO_DOCUMENTO VARCHAR(20) UNIQUE NOT NULL,

NOMBRES VARCHAR(100) NOT NULL,

APELLIDOS VARCHAR(100) NOT NULL,

FECHA_NACIMIENTO DATE NOT NULL,

GENERO ENUM('M', 'F', 'Otro', 'Prefiero no decir'),

EMAIL VARCHAR(150) UNIQUE NOT NULL,

TELEFONO VARCHAR(20),

CELULAR VARCHAR(20),

DIRECCION TEXT,

CIUDAD VARCHAR(100),

DEPARTAMENTO VARCHAR(100),

ESTRATO INT,

ESTADO_CIVIL ENUM('Soltero', 'Casado', 'Unión Libre', 'Divorciado', 'Viudo'),

FECHA_REGISTRO TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

ACTIVO BOOLEAN DEFAULT TRUE,

CHECK (ESTRATO BETWEEN 1 AND 6),

CHECK (FECHA_NACIMIENTO < CURRENT_DATE - INTERVAL '15 years')

);

CREATE TABLE INSCRIPCIONES_JSCG (

ID_INSCRIPCION INT PRIMARY KEY AUTO_INCREMENT,

ID_ESTUDIANTE INT NOT NULL,

ID_PROGRAMA INT NOT NULL,

FECHA_INSCRIPCION DATE DEFAULT CURRENT_DATE,

SEMESTRE_INGRESO INT NOT NULL,

AÑO_INGRESO INT NOT NULL,

ESTADO ENUM('Activo', 'Graduado', 'Retirado', 'Suspendido', 'Aplazado')

DEFAULT 'Activo',

PROMEDIO_ACUMULADO DECIMAL(4,2) DEFAULT 0.00,

CREDITOS_APROBADOS INT DEFAULT 0,

FECHA_ESTADO TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

OBSERVACIONES TEXT,

FOREIGN KEY (ID_ESTUDIANTE) REFERENCES ESTUDIANTES_JSCG(ID_ESTUDIANTE),

FOREIGN KEY (ID_PROGRAMA) REFERENCES PROGRAMAS_ACADEMICOS_JSCG(ID_PROGRAMA),

UNIQUE (ID_ESTUDIANTE, ID_PROGRAMA),

CHECK (PROMEDIO_ACUMULADO BETWEEN 0 AND 5),

CHECK (CREDITOS_APROBADOS >= 0),

CHECK (SEMESTRE_INGRESO BETWEEN 1 AND 2),

CHECK (AÑO_INGRESO >= 2000)

);

CREATE TABLE CURSOS_JSCG (

ID_CURSO INT PRIMARY KEY AUTO_INCREMENT,

ID_PROGRAMA INT NOT NULL,

CODIGO_CURSO VARCHAR(20) UNIQUE NOT NULL,

NOMBRE_CURSO VARCHAR(200) NOT NULL,

CREDITOS INT NOT NULL,

HORAS_SEMANALES INT,

NIVEL_SEMESTRE INT,

TIPO ENUM('Obligatoria', 'Electiva', 'Práctica', 'Proyecto') DEFAULT 'Obligatoria',

PREREQUISITOS TEXT,

DESCRIPTION TEXT,

ACTIVO BOOLEAN DEFAULT TRUE,

FOREIGN KEY (ID_PROGRAMA) REFERENCES PROGRAMAS_ACADEMICOS_JSCG(ID_PROGRAMA),

CHECK (CREDITOS > 0),

CHECK (HORAS_SEMANALES > 0),

CHECK (NIVEL_SEMESTRE > 0)

);

CREATE TABLE CALIFICACIONES_JSCG (

ID_CALIFICACION INT PRIMARY KEY AUTO_INCREMENT,

ID_INSCRIPCION INT NOT NULL,

ID_CURSO INT NOT NULL,

PERIODO_ACADEMICO VARCHAR(10) NOT NULL,

AÑO INT NOT NULL,

NOTA_DEFINITIVA DECIMAL(4,2),

ESTADO_CURSO ENUM('Cursando', 'Aprobado', 'Reprobado', 'Retirado', 'Validado'),

PORCENTAJE_ASISTENCIA DECIMAL(5,2),

FECHA_REGISTRO TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

FECHA_ACTUALIZACION TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

OBSERVACIONES TEXT,

FOREIGN KEY (ID_INSCRIPCION) REFERENCES INSCRIPCIONES_JSCG(ID_INSCRIPCION),

FOREIGN KEY (ID_CURSO) REFERENCES CURSOS_JSCG(ID_CURSO),

UNIQUE (ID_INSCRIPCION, ID_CURSO, PERIODO_ACADEMICO, AÑO),

CHECK (NOTA_DEFINITIVA BETWEEN 0 AND 5),

CHECK (PORCENTAJE_ASISTENCIA BETWEEN 0 AND 100)

);

DELIMITER //

CREATE TRIGGER trg_actualizar_promedio_jscg

AFTER INSERT ON CALIFICACIONES_JSCG

FOR EACH ROW

BEGIN

UPDATE INSCRIPCIONES_JSCG

SET

PROMEDIO_ACUMULADO = (

SELECT AVG(NOTA_DEFINITIVA)

FROM CALIFICACIONES_JSCG

WHERE ID_INSCRIPCION = NEW.ID_INSCRIPCION

AND ESTADO_CURSO IN ('Aprobado', 'Reprobado')

),

CREDITOS_APROBADOS = (

SELECT COALESCE(SUM(C.CREDITOS), 0)

FROM CALIFICACIONES_JSCG CAL

JOIN CURSOS_JSCG C ON CAL.ID_CURSO = C.ID_CURSO

WHERE CAL.ID_INSCRIPCION = NEW.ID_INSCRIPCION

AND CAL.ESTADO_CURSO = 'Aprobado'

)

WHERE ID_INSCRIPCION = NEW.ID_INSCRIPCION;

END//

DELIMITER ;

DELIMITER //

CREATE PROCEDURE sp_inscribir_curso_jscg(

IN p_id_inscripcion INT,

IN p_id_curso INT,

IN p_periodo VARCHAR(10),

IN p_año INT

)

BEGIN

DECLARE v_existe INT;

-- Verificar si ya está inscrito

SELECT COUNT(*) INTO v_existe

FROM CALIFICACIONES_JSCG

WHERE ID_INSCRIPCION = p_id_inscripcion

AND ID_CURSO = p_id_curso

AND PERIODO_ACADEMICO = p_periodo

AND AÑO = p_año;

IF v_existe > 0 THEN

SIGNAL SQLSTATE '45000'

SET MESSAGE_TEXT = 'El estudiante ya está inscrito en este curso para el periodo seleccionado';

ELSE

INSERT INTO CALIFICACIONES_JSCG

(ID_INSCRIPCION, ID_CURSO, PERIODO_ACADEMICO, AÑO, ESTADO_CURSO)

VALUES

(p_id_inscripcion, p_id_curso, p_periodo, p_año, 'Cursando');

END IF;

END//

DELIMITER ;
